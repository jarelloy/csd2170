//todo header


#version 450

#define BLOCK_SIZE 16
#define MASK_SIZE 3
#define SHARED_SIZE (BLOCK_SIZE + MASK_SIZE - 1)
#define MASK_RADIUS (MASK_SIZE / 2)
 

layout (local_size_x = BLOCK_SIZE, local_size_y = BLOCK_SIZE) in;
layout (binding = 0, rgba8) uniform readonly image2D inputImage;
layout (binding = 1, rgba8) uniform image2D resultImage;

const float kirsch[8][3][3] = {
        {
         {5, 5, 5},
         {-3, 0, -3},           /*rotation 1 */
         {-3, -3, -3}
         },
        {
         {5, 5, -3},
         {5, 0, -3},            /*rotation 2 */
         {-3, -3, -3}
         },
        {
         {5, -3, -3},
         {5, 0, -3},            /*rotation 3 */
         {5, -3, -3}
         },
        {
         {-3, -3, -3},
         {5, 0, -3},            /*rotation 4 */
         {5, 5, -3}
         },
        {
         {-3, -3, -3},
         {-3, 0, -3},           /*rotation 5 */
         {5, 5, 5}
         },
        {
         {-3, -3, -3},
         {-3, 0, 5},            /*rotation 6 */
         {-3, 5, 5}
         },
        {
         {-3, -3, 5},
         {-3, 0, 5},            /*rotation 7 */
         {-3, -3, 5}
         },
        {
         {-3, 5, 5},
         {-3, 0, 5},            /*rotation 8 */
         {-3, -3, -3}
         }
    };

//two extra row/col
shared vec3 sData[SHARED_SIZE][SHARED_SIZE];

void main()
{
  //Load shared data
  for (int iter = 0; iter <= (SHARED_SIZE * SHARED_SIZE) / (BLOCK_SIZE * BLOCK_SIZE); ++iter)
  {  
    uint tID = gl_LocalInvocationID.y * BLOCK_SIZE + gl_LocalInvocationID.x + iter * (BLOCK_SIZE * BLOCK_SIZE);
    uint sharedX = tID % SHARED_SIZE;
    uint sharedY = tID / SHARED_SIZE;
    uint uvX = gl_WorkGroupID.x * BLOCK_SIZE + sharedX - MASK_RADIUS; //Offset by half mask width
    uint uvY = gl_WorkGroupID.y * BLOCK_SIZE + sharedY - MASK_RADIUS;
    sData[sharedY][sharedX] = imageLoad(inputImage, ivec2(uvX, uvY)).rgb;
  }
  memoryBarrierShared();
  barrier();

  //Perform convolution
  vec3 maxSum = vec3(0.0);
  for (int mID = 0; mID < 8; ++mID)
  {
    vec3 localSum = vec3(0.0);

    for (int y = -1; y <= 1; ++y)
    {
      for (int x = -1; x <= 1; ++x)
      {
        localSum += sData[gl_LocalInvocationID.y + y+1][gl_LocalInvocationID.x + x+1] * kirsch[mID][y+1][x+1];
      }
    }

    maxSum = max(localSum, maxSum);
  }
  

  imageStore(resultImage, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), 
    vec4(min(max(maxSum / 8, 0), 1.0), 1.0));
}
 	
 
 
 
